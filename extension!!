(function (Scratch) {
  "use strict";

  let lastKey = '';
  const timestamps = Object.create(null);
  const hasOwn = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);

  // Listen for key presses and store last key pressed (lowercase single chars)
  document.addEventListener('keydown', e => {
    lastKey = e.key.length === 1 ? e.key.toLowerCase() : e.key;
  });

  class LastKeyTime {
    constructor() {}

    getInfo() {
      return {
        id: 'lastKeyTime',
        name: 'Last Key & Time',
        color1: '#3498db',

        blocks: [
          // INPUT CATEGORY LABEL
          { blockType: Scratch.BlockType.LABEL, text: 'Input' },

          {
            opcode: 'getLastKeyPressed',
            blockType: Scratch.BlockType.REPORTER,
            text: 'get last key pressed'
          },

          // TIMESTAMP CATEGORY LABEL
          { blockType: Scratch.BlockType.LABEL, text: 'Timestamps' },

          {
            opcode: 'recordTimestamp',
            blockType: Scratch.BlockType.COMMAND,
            text: 'record timestamp with id [ID]',
            arguments: {
              ID: { type: Scratch.ArgumentType.STRING, defaultValue: '1' }
            }
          },
          {
            opcode: 'getSecondsSinceTimestamp',
            blockType: Scratch.BlockType.REPORTER,
            text: 'seconds elapsed since timestamp id [ID]',
            arguments: {
              ID: { type: Scratch.ArgumentType.STRING, defaultValue: '1' }
            }
          },
          {
            opcode: 'isElapsedGreaterThan',
            blockType: Scratch.BlockType.BOOLEAN,
            text: 'has time since id [ID] exceeded [SECONDS] seconds?',
            arguments: {
              ID: { type: Scratch.ArgumentType.STRING, defaultValue: '1' },
              SECONDS: { type: Scratch.ArgumentType.NUMBER, defaultValue: 0 }
            }
          },
          {
            opcode: 'doesTimestampExist',
            blockType: Scratch.BlockType.BOOLEAN,
            text: 'does timestamp exist for id [ID]?',
            arguments: {
              ID: { type: Scratch.ArgumentType.STRING, defaultValue: '1' }
            }
          },
          {
            opcode: 'removeTimestamp',
            blockType: Scratch.BlockType.COMMAND,
            text: 'remove timestamp for id [ID]',
            arguments: {
              ID: { type: Scratch.ArgumentType.STRING, defaultValue: '1' }
            }
          },
          {
            opcode: 'getAllTimestampIDs',
            blockType: Scratch.BlockType.REPORTER,
            text: 'get list of all timestamp ids'
          },
          {
            opcode: 'clearAllTimestamps',
            blockType: Scratch.BlockType.COMMAND,
            text: 'clear all timestamps'
          }
        ]
      };
    }

    // Input block implementation
    getLastKeyPressed() {
      return lastKey;
    }

    // Timestamp block implementations
    recordTimestamp({ ID }) {
      timestamps[ID] = Date.now();
    }

    getSecondsSinceTimestamp({ ID }) {
      if (timestamps[ID]) {
        return +(((Date.now() - timestamps[ID]) / 1000).toFixed(5));
      }
      return 0;
    }

    isElapsedGreaterThan({ ID, SECONDS }) {
      if (timestamps[ID]) {
        return ((Date.now() - timestamps[ID]) / 1000) > SECONDS;
      }
      return false;
    }

    doesTimestampExist({ ID }) {
      return hasOwn(timestamps, ID);
    }

    removeTimestamp({ ID }) {
      delete timestamps[ID];
    }

    getAllTimestampIDs() {
      return JSON.stringify(Object.keys(timestamps));
    }

    clearAllTimestamps() {
      for (const key in timestamps) {
        delete timestamps[key];
      }
    }
  }

  Scratch.extensions.register(new LastKeyTime());
})(Scratch);
